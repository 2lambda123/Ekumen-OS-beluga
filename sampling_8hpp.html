<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Beluga: /home/runner/work/beluga/beluga/repository/beluga/include/beluga/algorithm/sampling.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Beluga
   </div>
   <div id="projectbrief">An extensible particle filter library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_1ad523cfdb7a3d7d09cddf672d6cd478.html">beluga</a></li><li class="navelem"><a class="el" href="dir_634c6b228f937c8a89fa81bc2f240134.html">algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sampling.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of algorithms related to generation, sampling and resampling of particles.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;<a class="el" href="exponential__filter_8hpp_source.html">beluga/algorithm/exponential_filter.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="spatial__hash_8hpp_source.html">beluga/algorithm/spatial_hash.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="type__traits_8hpp_source.html">beluga/type_traits.hpp</a>&gt;</code><br />
<code>#include &lt;range/v3/view/common.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/generate.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take_exactly.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/take_while.hpp&gt;</code><br />
<code>#include &lt;range/v3/view/transform.hpp&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sampling.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="sampling_8hpp__incl.png" border="0" usemap="#a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp" alt=""/></div>
<map name="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp" id="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hpp">
<area shape="rect" title="Implementation of algorithms related to generation, sampling and resampling of particles." alt="" coords="720,5,913,76"/>
<area shape="rect" title=" " alt="" coords="5,392,92,419"/>
<area shape="rect" title=" " alt="" coords="117,392,175,419"/>
<area shape="rect" title=" " alt="" coords="207,131,279,158"/>
<area shape="rect" title=" " alt="" coords="303,131,418,158"/>
<area shape="rect" href="exponential__filter_8hpp.html" title="Implementation of an exponential filter." alt="" coords="443,124,657,165"/>
<area shape="rect" href="spatial__hash_8hpp.html" title="Implementation of a spatial hash for N dimensional states." alt="" coords="418,303,599,344"/>
<area shape="rect" href="type__traits_8hpp.html" title="Includes all Beluga type traits." alt="" coords="733,131,901,158"/>
<area shape="rect" title=" " alt="" coords="1075,392,1286,419"/>
<area shape="rect" title=" " alt="" coords="975,131,1178,158"/>
<area shape="rect" title=" " alt="" coords="1203,131,1407,158"/>
<area shape="rect" title=" " alt="" coords="1431,131,1605,158"/>
<area shape="rect" title=" " alt="" coords="1630,124,1777,165"/>
<area shape="rect" title=" " alt="" coords="1801,124,1947,165"/>
<area shape="rect" title=" " alt="" coords="199,392,258,419"/>
<area shape="rect" title=" " alt="" coords="283,392,345,419"/>
<area shape="rect" title=" " alt="" coords="370,392,437,419"/>
<area shape="rect" title=" " alt="" coords="997,392,1052,419"/>
<area shape="rect" title=" " alt="" coords="693,392,785,419"/>
<area shape="rect" title=" " alt="" coords="461,392,521,419"/>
<area shape="rect" title=" " alt="" coords="546,392,669,419"/>
<area shape="rect" href="container__traits_8hpp.html" title="Useful traits for containers." alt="" coords="661,303,817,344"/>
<area shape="rect" href="particle__traits_8hpp.html" title="Implementation of traits for particle types, see the Particle named requirements." alt="" coords="783,213,927,255"/>
<area shape="rect" title=" " alt="" coords="810,392,973,419"/>
<area shape="rect" href="strongly__typed__numeric_8hpp.html" title="Implementation of a strongly typed numeric helper." alt="" coords="183,303,394,344"/>
<area shape="rect" href="views_8hpp.html" title="Implementation of useful container views." alt="" coords="943,310,1079,337"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sampling_8hpp__dep__incl.png" border="0" usemap="#a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep" alt=""/></div>
<map name="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep" id="a_2home_2runner_2work_2beluga_2beluga_2repository_2beluga_2include_2beluga_2algorithm_2sampling_8hppdep">
<area shape="rect" title="Implementation of algorithms related to generation, sampling and resampling of particles." alt="" coords="139,5,333,76"/>
<area shape="rect" href="algorithm_8hpp.html" title="Includes all beluga algorithms." alt="" coords="5,124,221,180"/>
<area shape="rect" href="localization_8hpp.html" title="Implementation of localization algorithms." alt="" coords="246,124,474,180"/>
<area shape="rect" href="beluga_8hpp.html" title="Includes all the Beluga API." alt="" coords="137,228,335,284"/>
</map>
</div>
</div>
<p><a href="sampling_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1RandomStateGenerator.html">beluga::RandomStateGenerator&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random state generator.  <a href="classbeluga_1_1RandomStateGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1NaiveSampler.html">beluga::NaiveSampler&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generation of samples from input particles.  <a href="classbeluga_1_1NaiveSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1AdaptiveSamplerParam.html">beluga::AdaptiveSamplerParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct an <a class="el" href="classbeluga_1_1AdaptiveSampler.html" title="Generation of samples from input particles with a recovery strategy.">AdaptiveSampler</a> instance.  <a href="structbeluga_1_1AdaptiveSamplerParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1AdaptiveSampler.html">beluga::AdaptiveSampler&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generation of samples from input particles with a recovery strategy.  <a href="classbeluga_1_1AdaptiveSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1FixedLimiterParam.html">beluga::FixedLimiterParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1FixedLimiter.html" title="Limiter policy that takes a fixed number of particles.">FixedLimiter</a> instance.  <a href="structbeluga_1_1FixedLimiterParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1FixedLimiter.html">beluga::FixedLimiter&lt; Mixin &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limiter policy that takes a fixed number of particles.  <a href="classbeluga_1_1FixedLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeluga_1_1KldLimiterParam.html">beluga::KldLimiterParam&lt; State &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used to construct a <a class="el" href="classbeluga_1_1KldLimiter.html" title="Limiter policy that takes a number of particles defined by the KLD criteria.">KldLimiter</a> instance.  <a href="structbeluga_1_1KldLimiterParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeluga_1_1KldLimiter.html">beluga::KldLimiter&lt; Mixin, State &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limiter policy that takes a number of particles defined by the KLD criteria.  <a href="classbeluga_1_1KldLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a01472d3e768837b5586985ef49337d27"><td class="memTemplParams" colspan="2">template&lt;class Function1 , class Function2 , class RandomNumberGenerator &gt; </td></tr>
<tr class="memitem:a01472d3e768837b5586985ef49337d27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a01472d3e768837b5586985ef49337d27">beluga::make_random_selector</a> (Function1 &amp;&amp;first, Function2 &amp;&amp;second, RandomNumberGenerator &amp;generator, double probability)</td></tr>
<tr class="memdesc:a01472d3e768837b5586985ef49337d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between executing one function or another randomly.  <a href="sampling_8hpp.html#a01472d3e768837b5586985ef49337d27">More...</a><br /></td></tr>
<tr class="separator:a01472d3e768837b5586985ef49337d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eae38886cb586def210def2b98ca57"><td class="memTemplParams" colspan="2">template&lt;class Range , class Weights , class RandomNumberGenerator &gt; </td></tr>
<tr class="memitem:a20eae38886cb586def210def2b98ca57"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a20eae38886cb586def210def2b98ca57">beluga::make_multinomial_sampler</a> (const Range &amp;samples, const Weights &amp;weights, RandomNumberGenerator &amp;generator)</td></tr>
<tr class="memdesc:a20eae38886cb586def210def2b98ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns multinomial resampler function.  <a href="sampling_8hpp.html#a20eae38886cb586def210def2b98ca57">More...</a><br /></td></tr>
<tr class="separator:a20eae38886cb586def210def2b98ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ff6407d74a1e7c72c1e5ea0cdc9bd"><td class="memTemplParams" colspan="2">template&lt;class Hasher &gt; </td></tr>
<tr class="memitem:a959ff6407d74a1e7c72c1e5ea0cdc9bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a959ff6407d74a1e7c72c1e5ea0cdc9bd">beluga::make_clusterization_function</a> (Hasher &amp;&amp;hasher)</td></tr>
<tr class="memdesc:a959ff6407d74a1e7c72c1e5ea0cdc9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that allows setting the cluster of a particle.  <a href="sampling_8hpp.html#a959ff6407d74a1e7c72c1e5ea0cdc9bd">More...</a><br /></td></tr>
<tr class="separator:a959ff6407d74a1e7c72c1e5ea0cdc9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sampling_8hpp.html#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">beluga::kld_condition</a> (std::size_t min, double epsilon, double z=3.)</td></tr>
<tr class="memdesc:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable object that verifies if the KLD condition is being satisfied.  <a href="sampling_8hpp.html#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">More...</a><br /></td></tr>
<tr class="separator:a4ef2ecb4492a73ec5d8c0c1c10b7ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of algorithms related to generation, sampling and resampling of particles. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4ef2ecb4492a73ec5d8c0c1c10b7ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2ecb4492a73ec5d8c0c1c10b7ea99">&#9670;&nbsp;</a></span>kld_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::kld_condition </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em> = <code>3.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that verifies if the KLD condition is being satisfied. </p>
<p>The callable object will compute the minimum number of samples based on a Kullback-Leibler distance epsilon between the maximum likelihood estimate and the true distribution. <br  />
Z is the upper standard normal quantile for P, where P is the probability that the error in the estimated distribution will be less than epsilon.</p>
<p>Here are some examples: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">P   </th><th class="markdownTableHeadNone">Z    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.900   </td><td class="markdownTableBodyNone">1.28155156327703    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.950   </td><td class="markdownTableBodyNone">1.64485362793663    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.990   </td><td class="markdownTableBodyNone">2.32634787735669    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.999   </td><td class="markdownTableBodyNone">3.09023224677087   </td></tr>
</table>
<p>If the computed value is less than what the min argument specifies, then min will be returned.</p>
<p>See KLD-Sampling: Adaptive Particle Filters <a class="el" href="citelist.html#CITEREF_fox2001adaptivekldsampling">[1]</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number of particles that the callable object will return. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum distance epsilon between the maximum likelihood estimate and the true distrubution. </td></tr>
    <tr><td class="paramname">z</td><td>Upper standard normal quantile for the probability that the error in the estimated distribution is less than epsilon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype <code>(std::size_t hash) -&gt; bool</code>. <code>hash</code> is the spatial hash of the particle being added. <br  />
 The returned callable object is stateful, tracking the total number of particles and the particle clusters based on the spatial hash. <br  />
 The return value of the callable will be false when the number of particles is more than the minimum and the KLD condition is satisfied, if not it will be true. <br  />
 i.e. A return value of true means that you need to keep sampling to satisfy the condition. </dd></dl>

</div>
</div>
<a id="a959ff6407d74a1e7c72c1e5ea0cdc9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959ff6407d74a1e7c72c1e5ea0cdc9bd">&#9670;&nbsp;</a></span>make_clusterization_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Hasher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::make_clusterization_function </td>
          <td>(</td>
          <td class="paramtype">Hasher &amp;&amp;&#160;</td>
          <td class="paramname"><em>hasher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable object that allows setting the cluster of a particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hasher</td><td>A copyable callable object with signature (const decltype(state(particle)) &amp;) -&gt; std::size_t, that returns a spatial cluster for a given particle state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A callable object with prototype <code>(ParticleT &amp;&amp; p) -&gt;ParticleT</code>. <br  />
 <code>ParticleT</code> must satisfy <a class="el" href="ParticlePage.html">Beluga named requirements: Particle</a>. \ n The expression <code>particle_traits&lt;ParticleT&gt;::cluster(p)</code> must also be valid and return a <code>std::size_t &amp;</code>. <br  />
 After the returned object is applied to a particle <code>p</code>, <code>cluster(p)</code> will be updated with the calculated spatial hash according to the specified resolutions in each axis. </dd></dl>

</div>
</div>
<a id="a20eae38886cb586def210def2b98ca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eae38886cb586def210def2b98ca57">&#9670;&nbsp;</a></span>make_multinomial_sampler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class Weights , class RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::make_multinomial_sampler </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weights &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns multinomial resampler function. </p>
<p>Returns a function that when called picks randomly a sample from the input range, with individual probabilities given by the weights of each. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> type, its iterator must be <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">random access</a>. </td></tr>
    <tr><td class="paramname">Weights</td><td>A <a href="https://en.cppreference.com/w/cpp/ranges/range">Range</a> type, its values must be convertible to double. </td></tr>
    <tr><td class="paramname">RandomNumberGenerator</td><td>Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator">UniformRandomBitGenerator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The container of samples to be picked. </td></tr>
    <tr><td class="paramname">weights</td><td>The weights of the samples to be picked. The size of the container must be the same as the size of samples. For a sample <code>samples[i]</code>, its weight is <code>weights[i]</code>. </td></tr>
    <tr><td class="paramname">generator</td><td>The random number generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampler function. Its type is the same as the <code>Range</code> value type. </dd></dl>

</div>
</div>
<a id="a01472d3e768837b5586985ef49337d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01472d3e768837b5586985ef49337d27">&#9670;&nbsp;</a></span>make_random_selector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function1 , class Function2 , class RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto beluga::make_random_selector </td>
          <td>(</td>
          <td class="paramtype">Function1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>probability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects between executing one function or another randomly. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function1</td><td>Callable type, with prototype <code>() -&gt; Ret</code>. </td></tr>
    <tr><td class="paramname">Function2</td><td>Callable type, with prototype <code>() -&gt; Ret</code>. The return type of both Function1 and Function2 must be the same. </td></tr>
    <tr><td class="paramname">RandomNumberGenerator</td><td>Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator">UniformRandomBitGenerator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first function to be called. </td></tr>
    <tr><td class="paramname">second</td><td>The second function to be called. </td></tr>
    <tr><td class="paramname">generator</td><td>The random number generator used. </td></tr>
    <tr><td class="paramname">probability</td><td>The first function will be called with the probability specified here. In the rest of the cases, second is called. A Bernoully distribution is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the called function. The return type is <code>decltype(first())</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
